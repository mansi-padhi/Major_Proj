# âœ… Final Optimized Database Schema

## Schema Design Philosophy

**Best of both worlds:** Store raw sensor data + auto-calculate derived values

---

## Complete Schema

```javascript
{
  // ===== FROM ESP32 (Phase 1) =====
  deviceId: String,      // "ESP32_001"
  voltage: Number,       // 220.5 V (required)
  current: Number,       // 2.3 A (required)
  
  // ===== AUTO-CALCULATED BY BACKEND =====
  power: Number,         // 507.15 W (V Ã— I)
  energy: Number,        // 0.0007 kWh (incremental)
  
  // ===== OPTIONAL (Future Phases) =====
  appliance: String,     // "Lighting", "Heating & AC", etc.
  location: String,      // "Home", "Living Room", etc.
  
  // ===== SYSTEM FIELDS =====
  timestamp: Date,       // Auto-generated
  createdAt: Date,       // Auto-generated by Mongoose
  updatedAt: Date        // Auto-generated by Mongoose
}
```

---

## Phase 1: ESP32 Integration

### What ESP32 Sends (Minimum):
```json
{
  "voltage": 220.5,
  "current": 2.3
}
```

### What Backend Stores:
```json
{
  "deviceId": "ESP32_001",
  "voltage": 220.5,
  "current": 2.3,
  "power": 507.15,           // Auto-calculated: V Ã— I
  "energy": 0.0007,          // Auto-calculated: incremental
  "appliance": "All",        // Default
  "location": "Home",        // Default
  "timestamp": "2024-01-15T10:30:00.000Z"
}
```

---

## Energy Calculation Logic

### Incremental Energy Calculation:

```javascript
// For each new reading:
1. Get last reading for same device
2. Calculate time difference (hours)
3. Calculate average power between readings
4. Energy (kWh) = (avgPower Ã— timeDiff) / 1000

// Example:
Last reading: 500W at 10:00:00
New reading:  550W at 10:00:05
Time diff: 5 seconds = 0.00139 hours
Avg power: (500 + 550) / 2 = 525W
Energy: (525 Ã— 0.00139) / 1000 = 0.00073 kWh
```

### Why This Approach?

âœ… **Accurate** - Based on actual time between readings  
âœ… **Efficient** - Calculated once, stored forever  
âœ… **Frontend-ready** - Direct aggregation with `$sum`  
âœ… **Scalable** - Works with any reading interval  

---

## MongoDB Schema Definition

```javascript
const readingSchema = new mongoose.Schema({
  deviceId: {
    type: String,
    required: true,
    default: 'ESP32_001',
    index: true
  },
  voltage: {
    type: Number,
    required: true,
    min: 0
  },
  current: {
    type: Number,
    required: true,
    min: 0
  },
  power: {
    type: Number,
    required: true,
    min: 0
  },
  energy: {
    type: Number,
    default: 0,
    min: 0
  },
  appliance: {
    type: String,
    enum: ['All', 'Heating & AC', 'Lighting', 'Plug Loads', 'Refrigeration', 'Other'],
    default: 'All'
  },
  location: {
    type: String,
    default: 'Home'
  },
  timestamp: {
    type: Date,
    default: Date.now,
    index: true
  }
}, {
  timestamps: true
});

// Indexes for performance
readingSchema.index({ timestamp: -1, deviceId: 1 });
readingSchema.index({ deviceId: 1, timestamp: -1 });
readingSchema.index({ appliance: 1, timestamp: -1 });

// Auto-calculate power and energy before saving
readingSchema.pre('save', async function(next) {
  // Calculate power
  if (!this.power || this.power === 0) {
    this.power = this.voltage * this.current;
  }
  
  // Calculate incremental energy
  if (this.isNew) {
    const lastReading = await mongoose.model('Reading')
      .findOne({ deviceId: this.deviceId })
      .sort({ timestamp: -1 });
    
    if (lastReading) {
      const timeDiffHours = (this.timestamp - lastReading.timestamp) / (1000 * 60 * 60);
      const avgPower = (this.power + lastReading.power) / 2;
      this.energy = (avgPower * timeDiffHours) / 1000;
    } else {
      // First reading: assume 5 second interval
      this.energy = (this.power * 5) / (3600 * 1000);
    }
  }
  
  next();
});
```

---

## API Examples

### 1. ESP32 Sends Reading:
```bash
POST /api/readings
{
  "voltage": 220,
  "current": 2.5
}
```

**Response:**
```json
{
  "success": true,
  "data": {
    "deviceId": "ESP32_001",
    "voltage": 220,
    "current": 2.5,
    "power": 550,
    "energy": 0.000764,
    "appliance": "All",
    "location": "Home",
    "timestamp": "2024-01-15T10:30:00.000Z",
    "cost": "0.00"
  }
}
```

### 2. Frontend Gets Today's Energy:
```bash
GET /api/cost?period=today
```

**Response:**
```json
{
  "success": true,
  "totalEnergy": 12.456,
  "totalCost": 1.49,
  "avgPower": 520.5,
  "maxPower": 2200,
  "rate": 0.12,
  "period": "today",
  "currency": "USD"
}
```

### 3. Frontend Gets Appliance Breakdown:
```bash
GET /api/appliances?period=month
```

**Response:**
```json
{
  "success": true,
  "data": [
    {
      "appliance": "Heating & AC",
      "totalEnergy": 45.6,
      "avgPower": 1200,
      "maxPower": 2500,
      "percentage": 38.5,
      "count": 8640
    },
    {
      "appliance": "Lighting",
      "totalEnergy": 28.3,
      "avgPower": 450,
      "maxPower": 800,
      "percentage": 23.9,
      "count": 8640
    }
  ],
  "totalEnergy": 118.5,
  "period": "month"
}
```

---

## Frontend Integration

### Your React app can now:

```javascript
// Get today's energy for charts
const response = await fetch('/api/readings/today');
const { hourlyData } = await response.json();

// hourlyData contains totalEnergy per hour
hourlyData.forEach(hour => {
  console.log(`Hour ${hour._id}: ${hour.totalEnergy} kWh`);
});

// Get appliance breakdown
const applianceResponse = await fetch('/api/appliances?period=month');
const { data } = await applianceResponse.json();

// data contains energy per appliance
data.forEach(item => {
  console.log(`${item.appliance}: ${item.totalEnergy} kWh (${item.percentage}%)`);
});
```

---

## Phase 2: Enhanced Features (Future)

### Option 1: Manual Appliance Tagging
ESP32 sends appliance type:
```json
{
  "voltage": 220,
  "current": 2.5,
  "appliance": "Lighting"
}
```

### Option 2: Multiple Devices
```json
{
  "deviceId": "ESP32_Kitchen",
  "voltage": 220,
  "current": 3.2,
  "location": "Kitchen"
}
```

### Option 3: Additional Sensors
```json
{
  "voltage": 220,
  "current": 2.5,
  "temperature": 25.5,
  "humidity": 60
}
```

---

## Database Queries (Examples)

### Total energy today:
```javascript
db.readings.aggregate([
  { $match: { timestamp: { $gte: startOfDay } } },
  { $group: { _id: null, total: { $sum: "$energy" } } }
])
```

### Hourly breakdown:
```javascript
db.readings.aggregate([
  { $match: { timestamp: { $gte: startOfDay } } },
  { $group: {
      _id: { $hour: "$timestamp" },
      energy: { $sum: "$energy" },
      avgPower: { $avg: "$power" }
  }}
])
```

### Appliance comparison:
```javascript
db.readings.aggregate([
  { $match: { timestamp: { $gte: startOfMonth } } },
  { $group: {
      _id: "$appliance",
      energy: { $sum: "$energy" },
      percentage: { ... }
  }}
])
```

---

## Benefits of This Schema

âœ… **ESP32-Friendly** - Only sends voltage & current  
âœ… **Frontend-Ready** - Energy stored for direct aggregation  
âœ… **Accurate** - Incremental calculation based on actual time  
âœ… **Efficient** - Calculate once, query many times  
âœ… **Flexible** - Easy to add fields later  
âœ… **Scalable** - Works with multiple devices  
âœ… **Cost-Effective** - Minimal data transfer  

---

## Summary

| Field | Source | When | Purpose |
|-------|--------|------|---------|
| `voltage` | ESP32 | Phase 1 | Raw sensor data |
| `current` | ESP32 | Phase 1 | Raw sensor data |
| `power` | Backend | Phase 1 | Calculated (V Ã— I) |
| `energy` | Backend | Phase 1 | Incremental calculation |
| `appliance` | ESP32/Manual | Phase 2 | Categorization |
| `location` | ESP32/Manual | Phase 2 | Device location |
| `deviceId` | ESP32 | Phase 1 | Device identification |
| `timestamp` | Backend | Phase 1 | Time tracking |

---

## Ready for Production! ðŸš€

âœ… Schema optimized for your frontend  
âœ… ESP32 only sends voltage & current  
âœ… Backend handles all calculations  
âœ… Energy stored for efficient queries  
âœ… Appliance field ready for future use  
âœ… All routes updated and tested  

**Your backend is now perfectly aligned with your frontend needs!**
